BAYESIAN BELIEF NETWORK üôå
https://www.javatpoint.com/bayesian-belief-network-in-artificial-intelligence
.
.
KNN ALGORITHMüôå
The K-Nearest Neighbors (K-NN) algorithm has several important characteristics that define its behavior and suitability for various tasks in machine learning:

1. *Instance-Based Learning:*
   K-NN is an instance-based learning algorithm, also known as a lazy learner. It doesn't build an explicit model during training; instead, it stores the entire training dataset and makes predictions by comparing new instances to these stored examples.

2. *Non-Parametric Algorithm:*
   K-NN is considered a non-parametric algorithm because it doesn't make assumptions about the underlying distribution of the data. It doesn't assume a specific functional form for the relationships between features and output.

3. *Distance-Based Metric:*
   The algorithm relies on a distance metric (e.g., Euclidean distance, Manhattan distance) to measure the similarity between data points. The choice of distance metric can impact the algorithm's performance and sensitivity to different feature scales.

4. *K-Value Selection:*
   The user needs to choose the value of k, which represents the number of neighbors considered when making predictions. The selection of k can affect the bias-variance trade-off and the generalization performance of the algorithm.

5. *Majority Voting (Classification) / Averaging (Regression):*
   For classification tasks, K-NN uses majority voting among the k nearest neighbors to predict the class label of a new instance. In regression tasks, it uses averaging (or weighted averaging) of the target values of the neighbors for prediction.

6. *Local Patterns:*
   K-NN captures local patterns in the data, making it suitable for problems where the decision boundary might be complex or irregular. It's sensitive to the distribution of data points in the feature space.

7. *Scalability and Efficiency:*
   K-NN's computational complexity increases with the size of the training dataset, as it requires calculating distances to all training instances during prediction. This can make K-NN computationally expensive for large datasets.

8. *Feature Scaling:*
   Feature scaling can significantly impact K-NN's performance since the distance metric is influenced by feature scales. It's often a good practice to normalize or standardize features before applying K-NN.

9. *Handling Noisy Data and Outliers:*
   K-NN can be sensitive to noisy data and outliers, as they can affect distance calculations and influence prediction outcomes. Using an appropriate distance metric and considering outlier handling techniques is important.

10. *Imbalanced Data:*
    K-NN may struggle with imbalanced datasets, where one class is significantly more prevalent than others. It can lead to biased predictions toward the majority class.

11. *Curse of Dimensionality:*
    K-NN's performance can degrade in high-dimensional spaces due to the "curse of dimensionality," where distances between points become less informative and similar.

In summary, the K-Nearest Neighbors algorithm's characteristics include its instance-based nature, reliance on distance metrics, sensitivity to k-value and feature scaling, ability to capture local patterns, and challenges related to scalability and handling noisy data. It's a versatile algorithm that can be effective for certain types of problems and datasets when used appropriately.
.
.
.
DECISION TREEüôå
When building a decision tree in machine learning, the choice of the splitting attribute at each node is a critical step that determines how well the tree can capture patterns and make accurate predictions. There are several measures (also known as splitting criteria) used to evaluate potential splitting attributes and decide which one is the best choice. Here are some of the most commonly used measures:

1. *Gini Impurity:*
   Gini impurity measures the probability of incorrectly classifying a randomly chosen element in a dataset. It quantifies the impurity or diversity of a set of elements with respect to their class labels. A lower Gini impurity indicates a better split.
   - Formula: Gini(D) = 1 - Œ£(p_i)^2, where p_i is the proportion of instances of class i in the dataset D.
   - The splitting attribute with the lowest weighted sum of Gini impurities across child nodes is selected.

2. *Entropy:*
   Entropy is a measure of the disorder or randomness within a set of elements based on their class labels. It's commonly used as a splitting criterion in decision trees.
   - Formula: Entropy(D) = - Œ£(p_i * log2(p_i)), where p_i is the proportion of instances of class i in the dataset D.
   - The attribute that results in the greatest reduction in entropy across child nodes is chosen as the splitting attribute.

3. *Information Gain:*
   Information gain is the reduction in entropy achieved by partitioning the dataset based on a particular attribute. It quantifies the amount of uncertainty that is removed from the dataset after the split.
   - Formula: Information Gain(D, A) = Entropy(D) - Œ£((|D_v| / |D|) * Entropy(D_v)), where A is the splitting attribute and D_v is the subset of instances associated with value v of attribute A.
   - The attribute with the highest information gain is selected as the splitting attribute.

4. *Gain Ratio:*
   Gain ratio is an enhancement of information gain that accounts for the potential bias of information gain towards attributes with a large number of values. It corrects for this bias by considering the intrinsic information of the attribute values.
   - Formula: Gain Ratio(D, A) = Information Gain(D, A) / Split Information(D, A), where Split Information(D, A) is a measure of the potential information generated by the values of attribute A.
   - The attribute with the highest gain ratio is chosen for splitting.

5. *Chi-Square Test:*
   The Chi-Square test is a statistical test that measures the independence between attributes and class labels. It's used to determine whether a particular attribute is significant for splitting.
   - The Chi-Square test computes a statistic that compares the observed and expected frequencies of class labels for different attribute values.
   - Attributes with a significant Chi-Square statistic are considered good candidates for splitting.

Each of these measures has its own strengths and weaknesses, and the choice of measure can depend on factors such as the nature of the data, the problem domain, and the desired characteristics of the resulting decision tree. It's important to understand and consider the implications of each measure when building decision trees for different applications.
.
A decision tree is a popular machine learning algorithm used for both classification and regression tasks. It's a graphical representation of a decision-making process, where each node in the tree represents a decision, a test on an attribute, or a target value, and each branch represents an outcome or decision based on the test. Decision trees are used in a wide range of applications, including medical diagnosis, customer churn prediction, and credit risk assessment, among others.
.
The process of creating a decision tree from a dataset is known as decision tree induction. Here are the various steps involved in decision tree induction:
steps :
Data Preparation:

Gather and preprocess your dataset. This may involve handling missing values, encoding categorical variables, and splitting the data into training and testing sets.
Attribute Selection Measure:

Choose an attribute selection measure to determine the best attribute to split the data at each node of the tree. Common measures include Information Gain, Gain Ratio, and Gini Index. These measures quantify how well an attribute separates the data into distinct classes or groups.
Tree Initialization:

Create the root node of the decision tree. This node represents the entire dataset.
Node Splitting:

At each node, select the attribute that best splits the data according to the chosen attribute selection measure. Splitting involves dividing the data into subsets based on the attribute's values.
Recursive Tree Building:
.
'Advantages of Decision Trees:

Interpretability: Decision trees provide a clear and intuitive representation of decision-making processes. They are easy to understand and can be visualized graphically, making them valuable for explaining the reasoning behind predictions.

No Data Preprocessing Required: Decision trees can handle both numerical and categorical data without the need for extensive data preprocessing, such as feature scaling or one-hot encoding.

Handle Non-Linear Relationships: Decision trees can capture complex non-linear relationships in the data, making them suitable for tasks where the decision boundaries are not simple.

Feature Importance: Decision trees can rank the importance of features based on how often they are used for splitting. This information can be helpful for feature selection and understanding the importance of variables in the problem.

Robust to Outliers: Decision trees are relatively robust to outliers because they make decisions based on splits and don't rely on the mean or other statistical measures that can be affected by outliers.

Can Handle Missing Values: Decision trees can handle datasets with missing values by considering the available data for each split without requiring imputation techniques.

Versatility: Decision trees can be used for both classification and regression tasks.
.
Disadvantages of Decision Trees:
Instability: Small changes in the data can result in different tree structures. This instability can make decision trees sensitive to variations in the dataset.
.
The number of nodes and branches in a decision tree can grow exponentially with the number of features, making it computationally expensive for datasets with many attributes
.
Global Optimum vs. Local Optimum: Decision tree induction is a greedy process that makes locally optimal decisions at each node. These local optima may not necessarily lead to the best overall tree structure.
.
(Step 1) Create a node N;

 (Step 2) If tuples in D are all of the same class, C then 

 (Step 3) Return N as a leaf node labeled with the class C;

 (Step 4) If attribute list is empty then 

 (Step 5) Return N as a leaf node labeled with the majority class in D; // majority voting

 (Step 6) Apply Attribute selection method(D, attribute list) to find the ‚Äúbest‚Äù splitting criterion;

 (Step 7) Label node N with splitting criterion;

 (Step 8) If splitting attribute is discrete-valued and multiway splits allowed, then // not restricted to  binary trees

 (Step 9) Attribute list ‚Üê attribute list ‚àí splitting attribute; // remove splitting attribute

 (Step 10) For each outcome j of splitting criterion // partition the tuples and grow subtrees for each partition

 (Step 11) Let Dj be the set of data tuples in D satisfying outcome j; // a partition

 (Step 12) If Dj is empty then

 (Step 13) Attach a leaf labeled with the majority class in D to node N;

 (Step 14) Else attach the node returned by Generate decision tree(Dj , attribute list) to node N; end for  

(Step 15) Return N;
.
.
.
NAIVE BAYES CLASSIFIER üôå
The Naive Bayes classifier is a probabilistic machine learning algorithm based on Bayes' theorem and the assumption of independence among features. It is commonly used for classification tasks, such as text classification (spam detection, sentiment analysis), document categorization, and email filtering. Despite its simplicity and the "naive" assumption, Naive Bayes can often perform surprisingly well in practice.
.
formula for bayes theorem
P(class‚à£features)= 
P(features)
P(features‚à£class)‚àóP(class)
‚Äã
.
Naive Assumption:
The "naive" part of Naive Bayes comes from the assumption of feature independence. It assumes that all features used in the classification are conditionally independent of each other, given the class label. In other words, it assumes that the presence or absence of one feature does not affect the presence or absence of any other feature. This is a simplifying assumption that may not hold true in all cases but often works well in practice.
.


